## Представления в PostgreSQL

Представление можно считать именованным запросом или оберткой вокруг команды SELECT. 
Представления – существенный строительный блок реляционных баз данных с точки зрения UML-моделирования; его можно интерпретировать как метод UML-класса. 
Представления используются для следующих целей:
1. упростить сложные запросы и повысить степень модульности кода;
2. повысить производительности посредством кеширования результатов и использования их в будущем;
3. уменьшить объем SQL-кода;
4. перебросить мост между реляционными базами данных и объектно-ориентированными языками (особенно в этом смысле полезны обновляемые представления);
5. реализовать авторизацию на уровне строк – не давать доступа к строкам, не удовлетворяющим заданному условию;
6. реализовать интерфейс и уровень абстракции, расположенного
между языками высокого уровня и реляционными базами;
7. реализовать срочные изменения.

В PostgreSQL представление — это виртуальная таблица. 
Она составляется на основе данных из обычных таблиц, обеспечивает удобный и интуитивно понятный способ организации информации. 
Важно отметить, что представления сами по себе не хранят данные, а лишь выполняют описанный в себе запрос.

Представление должно отвечать текущим, а не предполагаемым
будущим потребностям бизнеса. 
Его следует проектировать с учетом представления конкретной функциональности. 
Чем больше в представлении атрибутов, тем больше усилий придется приложить для его рефакторинга. 
Кроме того, если представление агрегирует данные из многих таблиц и используется в качестве интерфейса, то возможно снижение производительности. 
Причин тому много, например неоптимальный план выполнения из-за устаревшей статистики некоторых таблиц и т.д.

Активное использование представлений — это ключевой аспект хорошего проектирования баз данных SQL. Представления позволяют вам скрыть внутреннее устройство ваших таблиц, которые могут меняться по мере развития приложения, за надёжными интерфейсами.

## Операторы CREATE VIEW и REPLACE VIEW

Оператор CREATE VIEW используется в PostgreSQL для создания представления, а REPLACE VIEW — для его обновления.

Синтаксис операторов выглядит следующим образом:
```
CREATE [ OR REPLACE ] VIEW view_name [ (column_name [, ...] ) ]
AS
    select_statement
[ WITH [ CASCADED | LOCAL ] CHECK OPTION ];
```

* CREATE VIEW —ключевое слово, которое указывает на создание представления.
* REPLACE — опциональное ключевое слово, которое позволяет заменить имеющееся представление с тем же именем, если оно уже существует.
* view_name — имя представления, которое вы хотите создать.
* column_name — опциональный список имен столбцов, которые вы хотите включить в представление. Если не указан, представление будет содержать все столбцы, которые возвращает запросом.
* select_statement —запрос SELECT, определяющий данные, которые будут возвращены представлением.
* WITH [ CASCADED | LOCAL ] CHECK OPTION —опциональная фраза, которая позволяет применять ограничения CHECK при вставке или обновлении данных через представление. CASCADED применяет ограничения CHECK к базовым таблицам, LOCAL — только к представлению.

Пример работы с оператором CREATE VIEW:
```
CREATE VIEW employee_view AS
SELECT employee_id, first_name, last_name, department
FROM employees
WHERE department = 'IT';
```
В примере создается представление employee_view, 
которое будет содержать столбцы employee_id, first_name, last_name и department из таблицы employees, где значение столбца department равно «IT».

Удаление представления
Чтобы удалить представление, используется оператор DROP VIEW. Его синтаксис в PostgreSQL выглядит следующим образом:

```
DROP VIEW [ IF EXISTS ] view_name [, ...] [ CASCADE | RESTRICT ];
```
* DROP VIEW — ключевое слово, которое указывает на удаление представления.
* IF EXISTS — опциональное ключевое слово, которое позволяет игнорировать ошибку, если представление с указанным именем не существует.
* view_name — имя представления, которое вы хотите удалить.
* CASCADE или RESTRICT — опциональные ключевые слова, которые определяют, что произойдет с другими объектами, зависящими от представления. CASCADE удалит эти объекты вместе с представлением, а RESTRICT предотвратит удаление представления, если на него есть зависимые объекты.

Пример работы с оператором DROP VIEW:

```
DROP VIEW employee_view;
```
В примере удаляется представление с именем employee_view.

Пример удаления нескольких представлений:
```
DROP VIEW IF EXISTS employee_view, department_view CASCADE;
```

Вывод списка представлений в PostgreSQL
```
SELECT table_name
FROM information_schema.tables
WHERE table_type = 'VIEW' AND table_schema = 'public';
```

## Категории представлений

В PostgreSQL имеется несколько категорий представлений.
1. Временные представления. Такое представление автоматически
удаляется в конце сеанса. Если ключевое слово TEMPORARY или TEMP отсутствует, то жизненный цикл представления начинается в момент создания и заканчивается в момент явного удаления.
2. Рекурсивные представления. Рекурсивное представление напоминает рекурсивную функцию в языках программирования. Список столбцов в этом случае обязателен. Рекурсия, в частности рекурсивные представления и рекурсивные общие табличные выражения (CTE), позволяет строить очень сложные запросы, особенно для иерархически организованных данных.
3. Обновляемые представления. Обновляемые представления позволяют обращаться с представлениями, как с таблицами, т. е. выполнять команды INSERT, UPDATE и DELETE . Обновляемые представления в какой-то мере можно рассматривать как мост между реляционной и объектной моделями, они дают некий аналог полиморфизма.
4. Материализованные представления. Это таблица, содержимое которой периодически обновляется заранее заданным запросом. Материализованные представления повышают производительность запросов, которые выполняются долго, и часто применяются к статическим данным. Можно считать их вариантом кеширования. Рекурсия будет рассмотрена в последующих главах, а здесь мы сосредоточимся на обновляемых и материализованных представлениях.

В рамках лабораторной работы рассмотрим обновляемые и материализованные представления.

## Обновляемые представления
По умолчанию простые представления в PostgreSQL являются автообновляемыми, т. е. к ним можно применять команды DELETE, INSERT и UPDATE , которые воздействуют на данные в базовой таблице. Если представление не является обновляемым (а значит, и простым) из-за нарушения одного из перечисленных ниже ограничений, то его все-таки можно сделать таковым с помощью триггеров и правил.
Представление является автоматически обновляемым, если выполнены следующие условия:

* представление должно быть построено только над одной таблицей или одним обновляемым представлением;
* определение представления не содержит на верхнем уровне следующих фраз и теоретико-множественных операторов: DISTINCT, WITH, GROUP BY, OFFSET, HAVING, LIMIT, UNION, EXCEPT, INTERSECT;
* в списке select должны быть только сами столбцы базовой таблицы, использование функций и выражений не допускается. Кроме того, столбцы не должны повторяться;
* не должно быть установлено свойство security_barrier.

__Пример.__
Для сайта торговли автомобилями можно определить обновляемое
представление, показывающее только учетные записи, не принадлежащие
продавцам:
```
CREATE VIEW user_account AS
SELECT account_id, first_name, last_name, email, password
FROM account WHERE account_id NOT IN (SELECT account_id FROM seller_account);
```
Для проверки попробуем вставить в него строку:

```
INSERT INTO user_account VALUES (default,'first_name1','last_name1','test@email.com','password');
```

##  Материализованные представления

Материализованные представления часто используются совместно с хранилищами данных. В этом случае выполняется ряд запросов в интересах бизнес-аналитики и поддержки принятия решений. Данные втаких приложениях изменяются редко, но вычисления и агрегирование занимают много времени.

В общем случае материализованные представления применяются для следующих целей:
* формирование сводных отчетов;
* кеширование результатов повторяющихся запросов;
* повышение производительности благодаря однократной обработке
данных.

Поскольку материализованные представления – это таблицы, их можно
индексировать, что резко ускоряет работу с ними.

Синтаксис определения материализованных и обычных представлений
несколько различается. Материализованные представления – расширение
PostgreSQL. Как показано ниже, материализованное представление можно создать
в определенном табличном пространстве, и для него можно задать параметром
хранения storage_parameter , что вполне логично, т. к. материализованные
представления – физические объекты:

```
CREATE MATERIALIZED VIEW [ IF NOT EXISTS ] table_name [ (column_name [, ...] ) ]
[ WITH ( storage_parameter [= value] [, ... ] ) ]
[ TABLESPACE tablespace_name ]
AS query
[ WITH [ NO ] DATA ]
```

В момент создания материализованного представления его можно заполнить или оставить пустым. Для заполнения пустого материализованного представления служит команда REFRESH MATERIALIZED VIEW с таким
синтаксисом:
```
REFRESH MATERIALIZED VIEW [ CONCURRENTLY ] name [ WITH [ NO ] DATA ]
```
__Пример.__
В базе данных есть таблица с именем "film_category", где у всех комедийных фильмов есть "category_id", равный 4. 
В этом примере мы будем использовать концепцию материализованного представления для фильтрации "film_id" всех комедийных фильмов в базе данных.
```
CREATE MATERIALIZED VIEW comedy_movie_list AS
SELECT film_id 
FROM film_category 
WHERE category_id=4 
WITH DATA ;
```
Этот запрос создает материализованное представление с именем ‘comedy_movie_list' , в котором хранятся ‘film_id' все комедийные фильмы.


__Постановка задачи:__ В соответствии с вариантами индивидуальных заданий, выбранными в рамках лабораторной работы (L1.md), создайте sql-скрипты для реализации следующих операций манипулирования данными:
1. Создайте материализованное представление (более двух). 
2. Создайте обновляемое представление (более двух).
3. Продемонстрируйте использование представлений.