## Создание и управление пользователями

В PostgreSQL пользователи (или «роли») — это сущности, которым можно предоставлять различные привилегии.

Для выводы списка пользователей и ролей в СУБД выполните команду: 
```
\du 
```
С помощью инструмента createuser cоздадим нового пользователя: 
```
createuser –U postgres name
```
(где name - имя нового пользователя)

Создание нового пользователя c паролем:
```
CREATE USER name WITH PASSWORD 'S467@63!hfnmH6';
```

Изменение пароля пользователя:
```
ALTER USER name WITH PASSWORD 'new_password';
```
Удаление пользователя:
```
DROP USER name;
```
(где name - имя пользователя)

Роли базы данных являются глобальными для всей установки кластера базы данных (не для отдельной базы данных). 

Для создания роли используется команда SQL:
```
DROP ROLE имя;
```

Каждое подключение к серверу базы данных выполняется под именем конкретной роли, и эта роль определяет начальные права доступа для команд, выполняемых в этом соединении. 
Имя роли для конкретного подключения к базе данных указывается клиентской программой характерным для неё способом, таким образом инициируя запрос на подключение. Например, программа psql для
Роли базы данных указания роли использует аргумент командной строки -U.

__Атрибуты ролей__

Роль базы данных может иметь атрибуты, определяющие её полномочия и взаимодействие с системой аутентификации клиентов.

__Право подключения__

Только роли с атрибутом LOGIN могут использоваться для начального подключения к базе данных. Роль с атрибутом LOGIN можно рассматривать как пользователя базы данных. Для создания такой роли можно использовать любой из вариантов:
```
CREATE ROLE имя LOGIN; 
CREATE USER имя;
```
(Команда CREATE USER эквивалентна CREATE ROLE за исключением того, что CREATE USER по умолчанию включает атрибут LOGIN, в то время как CREATE ROLE — нет.)

__Статус суперпользователя__

Суперпользователь базы данных обходит все проверки прав доступа, за исключением права на вход в систему. Это опасная привилегия и она не должна использоваться небрежно. 
Лучше всего выполнять большую часть работы не как суперпользователь. 
Для создания нового суперпользователя используется:
```
CREATE ROLE имя SUPERUSER; 
```
Это нужно выполнить из под роли, которая также является суперпользователем.

__Создание базы данных__

Роль должна явно иметь разрешение на создание базы данных (за исключением суперпользователей, которые пропускают все проверки). 
Для создания такой роли используется:
```
CREATE ROLE имя CREATEDB;
```
__Создание роли__

Роль должна явно иметь разрешение на создание других ролей (за исключением суперпользователей, которые пропускают все проверки). 
Для создания такой роли используется:
```
CREATE ROLE имя CREATEROLE;
```
Роль с правом CREATEROLE может изменять и удалять роли, которые были назначены пользователю с правами CREATEROLE и ADMIN OPTION. Такое назначение ролей происходит автоматически, когда пользователь с правом CREATEROLE, не являющийся суперполь- зователем, создаёт новую роль. 
Поэтому по умолчанию пользователь с правом CREATEROLE мо- жет изменять и удалять созданные им роли. Изменение роли включает большинство действий команды ALTER ROLE, например смену пароля, а также действия команд COMMENT и SECURITY LABEL в отношении ролей.
Однако, имея право CREATEROLE, нельзя ни создавать, ни каким-либо образом влиять на роли SUPERUSER. Кроме того, с правом CREATEROLE нельзя ни создавать пользователей REPLICATION, ни предоставлять или отзывать право REPLICATION, ни изменять свойства ролей таких пользователей.

__Запуск репликации__

Роль должна иметь явное разрешение на запуск потоковой репликации (за исключением суперпользователей, которые пропускают все проверки). Роль, используемая для потоковой репликации, также должна иметь атрибут LOGIN. Для создания такой роли используется:
```
CREATE ROLE имя REPLICATION LOGIN;
```
__Пароль__

Пароль имеет значение, если метод аутентификации клиентов требует, чтобы пользователи предоставляли пароль при подключении к базе данных. 
Методы аутентификации password и md5 используют пароли. База данных и операционная система используют раздельные пароли. Пароль указывается при создании роли: 
```
CREATE ROLE имя PASSWORD 'строка';
```
__Наследование прав__

По умолчанию роль наследует права ролей, членом которых она является. Однако можно создать роль, которая не будет наследовать права по умолчанию. 
Для этого выполните CREATE ROLE имя NOINHERIT. Как вариант, атрибуты наследования отдельных прав можно переопределить, указав WITH INHERIT TRUE или WITH INHERIT FALSE.

__Игнорирование защиты на уровне строк__

Разрешение обходить все политики защиты на уровне строк (RLS) нужно давать роли явно. Создать роль с таким разрешением можно, выполнив CREATE ROLE имя BYPASSRLS от имени суперпользователя.

__Ограничение соединений__

Для роли можно ограничить число одновременных соединений. -1 (по умолчанию) означает отсутствие ограничения. Для создания роли с ограничением используется CREATE ROLE name CONNECTION LIMIT 'число'.

Создание роли с определенными атрибутами:

```
CREATE ROLE admin_role WITH 
    LOGIN
    SUPERUSER
    CREATEDB
    CREATEROLE
    INHERIT
    REPLICATION
    CONNECTION LIMIT -1;
```
__Назначение привилегий__

Предоставление привилегий на таблицу:

```
GRANT SELECT, INSERT, UPDATE ON table_name TO name;
```

Отзыв привилегий:
```
REVOKE INSERT ON table_name FROM name;
```

Предоставление всех привилегий на схему:
```
GRANT ALL ON SCHEMA public TO name;
```

Предоставление привилегий роли:
```
GRANT admin_role TO name;
```
Схемы в PostgreSQL — это способ организации объектов базы данных в логические группы. Они также играют важную роль в безопасности.

Создание новой схемы:
```
CREATE SCHEMA secure_schema;
```

Предоставление привилегий на схему:
```
GRANT USAGE ON SCHEMA secure_schema TO name;
```
Политики защиты

В дополнение к стандартной системе прав SQL, управляемой командой GRANT, на уровне таблиц можно определить политики защиты строк, ограничивающие для пользователей наборы строк, которые могут быть возвращены обычными запросами или добавлены, изменены и удалены командами, изменяющими данные. 
Это называется также защитой на уровне строк (RLS, Row-Level Security). 
По умолчанию таблицы не имеют политик, так что если система прав SQL разрешает пользователю доступ к таблице, все строки в ней одинаково доступны для чтения или изменения.
Когда для таблицы включается защита строк (с помощью команды ALTER TABLE ... ENABLE ROW LEVEL SECURITY), все обычные запросы к таблице на выборку или модификацию строк должны разрешаться политикой защиты строк.
(Однако на владельца таблицы такие политики обычно не действуют.) 
Если политика для таблицы не определена, применяется политика запрета по умолчанию, так что никакие строки в этой таблице нельзя увидеть или модифицировать. На операции с таблицей в целом, такие как TRUNCATE и REFERENCES, защита строк не распространяется.
Чтобы определить, какие строки будут видимыми или могут изменяться в таблице, для политики задаётся выражение, возвращающее логический результат.

В качестве примера, можно создать политику для отношения account, позволяющую только членам роли managers обращаться к строкам отношения и при этом только к своим, можно так:
```
CREATE TABLE accounts (manager text, company text, contact_email text);
ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;
CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);
```

__Аудит привилегий__

Для аудита привилегий в PostgreSQL можно использовать следующие методы:

1. Проверка привилегий для конкретного пользователя. Для этого нужно выполнить SQL-запрос: 
```
SELECT * FROM information_schema.role_table_grants WHERE grantee = 'username';
```
Он выведет список всех привилегий на уровне таблицы, предоставленных пользователю username. 

2. Просмотр общих привилегий для базы данных. Для этого можно использовать каталог pg_database: 
```
SELECT datname, datacl FROM pg_database;
```
Столбец datacl содержит списки контроля доступа (ACLs), показывающие привилегии пользователя для каждой базы данных.

3. Просмотр привилегий для всех пользователей. Для этого нужно выполнить запрос:
```
SELECT grantee, privilege_type FROM information_schema.role_table_grants;
```
Он выдаст полный список того, кто может что делать с какой таблицей.

4. Проверка привилегий на уровне схемы. Для этого можно использовать каталог pg_namespace:
```
SELECT nspname, nspacl FROM pg_catalog.pg_namespace;
```
Этот запрос покажет привилегии на уровне схемы, данные пользователям.

## Стратегии резервного копирования

Существует несколько стратегий резервного копирования:

1. Полное резервное копирование: копирование всей базы данных.
2. Инкрементное резервное копирование: копирование только изменений с момента последнего резервного копирования.
3. Дифференциальное резервное копирование: копирование изменений с момента последнего полного резервного копирования.

# __pg_dump__

pg_dump — это утилита PostgreSQL для создания резервных копий. 
Рассмотрим несколько примеров:

Для создания полной резервной копии базы данных:
```
pg_dump dbname > backup.sql
```

Для создания сжатой резервной копии:
```
pg_dump -Fc dbname > backup.dump
```

Для Mac:
```
pg_dump dbname | gzip > backup.gz
```
Для Windows:
```
pg_dump dbname | "C:\Program Files-Zipz.exe" a -si backup.7z
```

# __pg_restore__

pg_restore используется для восстановления баз данных из резервных копий, созданных pg_dump. 
Вот несколько примеров:

Для восстановления из файла SQL:
```
psql dbname < backup.sql
```

Для восстановления из сжатого файла:
```
pg_restore -d dbname backup.dump
```

Для Mac:
```
gunzip -c backup.gz | psql dbname

```

Для Windows:
```
"C:\Program Files-Zipz.exe" e -so backup.7z | psql dbname
```

# __Настройка непрерывного архивирования__

Непрерывное архивирование (или WAL архивирование) позволяет восстановить базу данных до любого момента времени. 

1. Отредактируйте postgresql.conf:
```
wal_level = replica
archive_mode = on
archive_command = 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'
```

2. Создайте базовую резервную копию:
```
pg_basebackup -D /mnt/server/basebackup

```

Для восстановления используйте recovery.conf:
```
restore_command = 'cp /mnt/server/archivedir/%f %p'
recovery_target_time = '2024-12-10 13:30:00'
```

__Постановка задачи:__ В соответствии с вариантами индивидуальных заданий, выбранными в рамках лабораторной работы (L1.md), выполните задания:
1. Создайте нового пользователя и предоставьте ему ограниченные привилегии на одну из ваших таблиц.
2. Настройте row-level security для таблицы, чтобы пользователи могли видеть только свои собственные записи.
3. Проведите аудит привилегий для всех пользователей в вашей базе данных.
4. Создайте полную резервную копию вашей тестовой базы данных.
5. Попробуйте восстановить эту базу данных на другом сервере или в другую базу данных.
6. Настройте непрерывное архивирование для вашей тестовой базы данных.